#!/usr/bin/env python3
"""
HUMAN 2.0 - Creator Agent
Creates new files and modules based on learned patterns.

This enables HUMAN to grow by creating new code, not just improving existing code.

Capabilities:
- Generate new Python modules
- Create utility files
- Build test files for existing code
- Generate configuration files
- Update __init__.py imports automatically
"""

import ast
import os
import logging
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime
from dataclasses import dataclass, asdict

import sys
sys.path.append(str(Path(__file__).parent.parent))

from agents.base_agent import BaseAgent, AgentStatus
from core.event_bus import EventBus, Event, EventTypes, EventPriority
from core.shared_resources import SharedResources

# Import LLM router if available
try:
    from llm.router import LLMRouter
    HAS_LLM_ROUTER = True
except ImportError:
    HAS_LLM_ROUTER = False


@dataclass
class ModuleSpec:
    """Specification for a new module."""
    name: str
    description: str
    module_type: str  # "utility", "agent", "component", "test", "config"
    target_directory: str
    dependencies: List[str]
    functions: List[Dict[str, str]]  # name -> description
    classes: List[Dict[str, str]]  # name -> description
    tags: List[str]


@dataclass
class CreationResult:
    """Result of module creation."""
    success: bool
    file_path: Optional[str]
    code_generated: str
    imports_updated: List[str]
    errors: List[str]
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


class CreatorAgent(BaseAgent):
    """
    Agent responsible for creating new files and modules.

    This agent enables HUMAN to grow its codebase by creating new:
    - Utility modules
    - Agent implementations
    - Component files
    - Test files
    - Configuration files

    Subscribes to:
    - creation_requested: Create new module
    - pattern_learned: Consider creating new module based on learned pattern

    Publishes:
    - module_created: New module successfully created
    - creation_failed: Module creation failed
    """

    # Templates for different module types
    MODULE_TEMPLATES = {
        "utility": '''"""
{description}

Auto-generated by HUMAN 2.0 Creator Agent.
"""

from typing import Dict, Any, List, Optional
import logging

logger = logging.getLogger(__name__)

{content}
''',
        "agent": '''#!/usr/bin/env python3
"""
HUMAN 2.0 - {name} Agent
{description}

Auto-generated by HUMAN 2.0 Creator Agent.
"""

import logging
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime

import sys
sys.path.append(str(Path(__file__).parent.parent))

from agents.base_agent import BaseAgent, AgentStatus
from core.event_bus import EventBus, Event, EventTypes, EventPriority
from core.shared_resources import SharedResources

{content}
''',
        "component": '''"""
HUMAN 2.0 - {name}
{description}

Auto-generated by HUMAN 2.0 Creator Agent.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
import logging

logger = logging.getLogger(__name__)

{content}
''',
        "test": '''"""
Tests for {name}
{description}

Auto-generated by HUMAN 2.0 Creator Agent.
"""

import pytest
from pathlib import Path
import sys

sys.path.append(str(Path(__file__).parent.parent / "src"))

{content}
''',
    }

    def __init__(self, name: str, event_bus: EventBus, resources: SharedResources):
        """Initialize Creator Agent."""
        super().__init__(name, event_bus)
        self.resources = resources

        # Initialize LLM router
        self.llm_router = None
        if HAS_LLM_ROUTER:
            try:
                self.llm_router = LLMRouter()
                self.logger.info("Creator agent using hybrid LLM")
            except Exception as e:
                self.logger.warning(f"LLM router failed: {e}")

        # Configuration
        self.config = {
            'base_directory': 'src',
            'test_directory': 'tests',
            'max_file_size': 10000,  # Max generated file size
            'auto_update_init': True,  # Auto-update __init__.py
        }

        # Stats
        self.files_created = 0
        self.creation_errors = 0

        self.logger.info("CreatorAgent initialized")

    def register_event_handlers(self):
        """Register event handlers."""
        self.event_bus.subscribe(EventTypes.CREATION_REQUESTED, self.on_creation_requested, self.name)
        self.event_bus.subscribe(EventTypes.PATTERN_LEARNED, self.on_pattern_learned, self.name)
        self.logger.info("Subscribed to: creation_requested, pattern_learned")

    async def on_creation_requested(self, event: Event):
        """Handle creation request."""
        spec = event.data.get('spec')
        if not spec:
            self.logger.error("No module spec in creation request")
            return

        task = {
            'type': 'create_module',
            'spec': spec
        }
        await self.execute_task(task)

    async def on_pattern_learned(self, event: Event):
        """Consider creating a module based on learned patterns."""
        patterns = event.data.get('patterns', [])

        # If we learned enough related patterns, consider creating a module
        if len(patterns) >= 3:
            self.logger.info(f"Learned {len(patterns)} patterns - considering module creation")
            # This is a placeholder for more sophisticated logic
            # Could analyze patterns and suggest new module creation

    async def process(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Process creation task."""
        task_type = task.get('type')

        if task_type == 'create_module':
            return await self._create_module(task['spec'])
        elif task_type == 'create_test':
            return await self._create_test_file(task['target_file'])
        else:
            raise ValueError(f"Unknown task type: {task_type}")

    async def _create_module(self, spec: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a new module based on specification.

        Args:
            spec: Module specification dict

        Returns:
            Creation result
        """
        # Convert dict to ModuleSpec if needed
        if isinstance(spec, dict):
            spec = ModuleSpec(
                name=spec.get('name', 'new_module'),
                description=spec.get('description', ''),
                module_type=spec.get('module_type', 'utility'),
                target_directory=spec.get('target_directory', self.config['base_directory']),
                dependencies=spec.get('dependencies', []),
                functions=spec.get('functions', []),
                classes=spec.get('classes', []),
                tags=spec.get('tags', [])
            )

        self.logger.info(f"Creating module: {spec.name} ({spec.module_type})")

        errors = []

        try:
            # 1. Search for similar patterns in knowledge base
            similar_patterns = self.resources.search_similar_code(
                query=f"{spec.description} {' '.join(spec.tags)}",
                n_results=3
            )

            # 2. Generate code using LLM
            code = await self._generate_module_code(spec, similar_patterns)

            if not code:
                return {
                    'success': False,
                    'error': 'Failed to generate code'
                }

            # 3. Validate syntax
            valid, syntax_error = self._validate_syntax(code)
            if not valid:
                self.logger.warning(f"Generated code has syntax error: {syntax_error}")
                # Try to fix
                code = await self._fix_syntax(code, syntax_error)
                valid, _ = self._validate_syntax(code)
                if not valid:
                    return {
                        'success': False,
                        'error': f'Syntax error: {syntax_error}'
                    }

            # 4. Determine file path
            file_path = self._determine_file_path(spec)

            # 5. Create parent directories
            Path(file_path).parent.mkdir(parents=True, exist_ok=True)

            # 6. Write file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(code)

            self.logger.info(f"Created file: {file_path}")

            # 7. Update __init__.py
            imports_updated = []
            if self.config['auto_update_init']:
                imports_updated = self._update_init_file(file_path, spec.name)

            # 8. Update stats
            self.files_created += 1

            # 9. Publish event
            await self.publish_event(
                EventTypes.MODULE_CREATED,
                {
                    'file_path': file_path,
                    'spec': asdict(spec),
                    'imports_updated': imports_updated
                },
                EventPriority.NORMAL
            )

            return {
                'success': True,
                'file_path': file_path,
                'code_length': len(code),
                'imports_updated': imports_updated
            }

        except Exception as e:
            self.creation_errors += 1
            self.logger.error(f"Module creation failed: {e}")

            await self.publish_event(
                EventTypes.CREATION_FAILED,
                {
                    'spec': asdict(spec) if isinstance(spec, ModuleSpec) else spec,
                    'error': str(e)
                },
                EventPriority.HIGH
            )

            return {
                'success': False,
                'error': str(e)
            }

    async def _generate_module_code(
        self,
        spec: ModuleSpec,
        similar_patterns: List[Dict]
    ) -> Optional[str]:
        """Generate module code using LLM."""

        # Build prompt
        prompt = self._build_generation_prompt(spec, similar_patterns)

        # Use LLM to generate
        if self.llm_router:
            code = await self.llm_router.generate(
                prompt=prompt,
                complexity=5,  # New modules are usually simple
                lines_of_code=100,
                max_tokens=4000,
                temperature=0.7
            )
        else:
            # Fallback: Use template with placeholders
            code = self._generate_from_template(spec)

        return code

    def _build_generation_prompt(
        self,
        spec: ModuleSpec,
        similar_patterns: List[Dict]
    ) -> str:
        """Build prompt for code generation."""

        prompt = f"""Create a Python module with the following specification:

NAME: {spec.name}
TYPE: {spec.module_type}
DESCRIPTION: {spec.description}

REQUIRED FUNCTIONS:
"""
        for func in spec.functions:
            prompt += f"- {func.get('name', 'function')}: {func.get('description', '')}\n"

        prompt += "\nREQUIRED CLASSES:\n"
        for cls in spec.classes:
            prompt += f"- {cls.get('name', 'Class')}: {cls.get('description', '')}\n"

        prompt += f"\nDEPENDENCIES: {', '.join(spec.dependencies)}\n"

        if similar_patterns:
            prompt += "\nSIMILAR PATTERNS FOR REFERENCE:\n"
            for pattern in similar_patterns[:2]:
                doc = pattern.get('document', '')[:500]
                prompt += f"\n{doc}\n"

        prompt += """
REQUIREMENTS:
- Return ONLY Python code, no explanations
- Include proper imports
- Add docstrings for all functions and classes
- Follow PEP 8 style
- Include type hints
- Make the code production-ready

Return the complete module code:
"""

        return prompt

    def _generate_from_template(self, spec: ModuleSpec) -> str:
        """Generate code from template (fallback when no LLM)."""

        template = self.MODULE_TEMPLATES.get(spec.module_type, self.MODULE_TEMPLATES['utility'])

        # Generate placeholder content
        content_lines = []

        for func in spec.functions:
            func_name = func.get('name', 'function')
            func_desc = func.get('description', 'TODO: Implement')
            content_lines.append(f'''
def {func_name}(*args, **kwargs):
    """{func_desc}"""
    # TODO: Implement this function
    raise NotImplementedError("{func_name} not yet implemented")
''')

        for cls in spec.classes:
            cls_name = cls.get('name', 'NewClass')
            cls_desc = cls.get('description', 'TODO: Implement')
            content_lines.append(f'''
class {cls_name}:
    """{cls_desc}"""

    def __init__(self):
        """Initialize {cls_name}."""
        pass

    # TODO: Add methods
''')

        content = '\n'.join(content_lines)

        return template.format(
            name=spec.name,
            description=spec.description,
            content=content
        )

    def _validate_syntax(self, code: str) -> tuple:
        """Validate Python syntax."""
        try:
            ast.parse(code)
            return True, ""
        except SyntaxError as e:
            return False, f"Line {e.lineno}: {e.msg}"

    async def _fix_syntax(self, code: str, error: str) -> str:
        """Attempt to fix syntax errors."""
        if not self.llm_router:
            return code

        prompt = f"""Fix the syntax error in this Python code:

SYNTAX ERROR: {error}

CODE:
```python
{code}
```

Return ONLY the corrected Python code, no explanations."""

        fixed = await self.llm_router.generate(
            prompt=prompt,
            complexity=2,
            lines_of_code=len(code.split('\n')),
            max_tokens=4000,
            temperature=0.1
        )

        return fixed if fixed else code

    def _determine_file_path(self, spec: ModuleSpec) -> str:
        """Determine the file path for the new module."""
        base_dir = spec.target_directory

        # Convert module name to file name
        file_name = spec.name.lower().replace(' ', '_').replace('-', '_')
        if not file_name.endswith('.py'):
            file_name += '.py'

        return os.path.join(base_dir, file_name)

    def _update_init_file(self, file_path: str, module_name: str) -> List[str]:
        """Update __init__.py to include the new module."""
        updated = []

        dir_path = Path(file_path).parent
        init_path = dir_path / '__init__.py'

        # Clean module name
        clean_name = module_name.lower().replace(' ', '_').replace('-', '_')
        if clean_name.endswith('.py'):
            clean_name = clean_name[:-3]

        try:
            # Read existing content
            if init_path.exists():
                content = init_path.read_text(encoding='utf-8')
            else:
                content = f'"""\n{dir_path.name} module\n"""\n\n'

            # Check if already imported
            import_line = f"from .{clean_name} import"
            if import_line in content:
                return []  # Already imported

            # Add import
            new_import = f"from .{clean_name} import *\n"
            content += new_import

            # Write back
            init_path.write_text(content, encoding='utf-8')
            updated.append(str(init_path))

            self.logger.info(f"Updated {init_path}")

        except Exception as e:
            self.logger.warning(f"Failed to update __init__.py: {e}")

        return updated

    async def _create_test_file(self, target_file: str) -> Dict[str, Any]:
        """Create a test file for an existing module."""

        target_path = Path(target_file)
        if not target_path.exists():
            return {'success': False, 'error': f'Target file not found: {target_file}'}

        # Read target module
        code = target_path.read_text(encoding='utf-8')

        # Extract functions and classes
        tree = ast.parse(code)
        items = []
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                items.append(('function', node.name))
            elif isinstance(node, ast.ClassDef):
                items.append(('class', node.name))

        # Create test spec
        test_name = f"test_{target_path.stem}"
        spec = ModuleSpec(
            name=test_name,
            description=f"Tests for {target_path.stem}",
            module_type='test',
            target_directory=self.config['test_directory'],
            dependencies=[target_path.stem],
            functions=[{'name': f'test_{name}', 'description': f'Test {type_} {name}'} for type_, name in items],
            classes=[],
            tags=['test', 'auto-generated']
        )

        return await self._create_module(spec)

    def validate_output(self, output: Any) -> bool:
        """Validate creation output."""
        if not isinstance(output, dict):
            return False
        return 'success' in output

    def get_stats(self) -> Dict[str, Any]:
        """Get creator statistics."""
        return {
            'files_created': self.files_created,
            'creation_errors': self.creation_errors,
            'success_rate': (
                self.files_created / (self.files_created + self.creation_errors)
                if (self.files_created + self.creation_errors) > 0 else 0
            )
        }


if __name__ == "__main__":
    import asyncio
    logging.basicConfig(level=logging.INFO)

    async def test():
        print("Testing Creator Agent...")

        # This is a standalone test - in real usage, would use event bus
        from core.event_bus import EventBus
        from core.shared_resources import SharedResources

        bus = EventBus()
        resources = SharedResources()

        agent = CreatorAgent("creator", bus, resources)

        # Test module creation
        spec = {
            'name': 'test_utility',
            'description': 'A test utility module',
            'module_type': 'utility',
            'target_directory': 'temp',
            'dependencies': ['logging'],
            'functions': [
                {'name': 'helper_function', 'description': 'A helper function'}
            ],
            'classes': [
                {'name': 'HelperClass', 'description': 'A helper class'}
            ],
            'tags': ['test', 'utility']
        }

        result = await agent._create_module(spec)
        print(f"\nResult: {result}")
        print(f"\nStats: {agent.get_stats()}")

    asyncio.run(test())
